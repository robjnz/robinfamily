var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/tsup/assets/cjs_shims.js
var importMetaUrlShim;
var init_cjs_shims = __esm({
  "node_modules/tsup/assets/cjs_shims.js"() {
    importMetaUrlShim = typeof document === "undefined" ? new (require("url")).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
  }
});

// node_modules/mlly/lib/_utils.mjs
function normalizeSlash(str) {
  return str.replace(/\\/g, "/");
}
var import_node_module, BUILTIN_MODULES;
var init_utils = __esm({
  "node_modules/mlly/lib/_utils.mjs"() {
    init_cjs_shims();
    import_node_module = __toModule(require("node:module"));
    BUILTIN_MODULES = new Set(import_node_module.builtinModules);
  }
});

// node_modules/mlly/lib/analyze.mjs
var init_analyze = __esm({
  "node_modules/mlly/lib/analyze.mjs"() {
    init_cjs_shims();
  }
});

// node_modules/mlly/lib/utils.mjs
function fileURLToPath(id) {
  if (typeof id === "string" && !id.startsWith("file://")) {
    return normalizeSlash(id);
  }
  return normalizeSlash((0, import_node_url.fileURLToPath)(id));
}
var import_node_url, import_node_fs;
var init_utils2 = __esm({
  "node_modules/mlly/lib/utils.mjs"() {
    init_cjs_shims();
    import_node_url = __toModule(require("node:url"));
    import_node_fs = __toModule(require("node:fs"));
    init_utils();
  }
});

// node_modules/mlly/lib/cjs.mjs
function createCommonJS(url) {
  const __filename2 = fileURLToPath(url);
  const __dirname = (0, import_node_path.dirname)(__filename2);
  let _nativeRequire;
  const getNativeRequire = () => _nativeRequire || (_nativeRequire = (0, import_node_module2.createRequire)(url));
  function require3(id) {
    return getNativeRequire()(id);
  }
  require3.resolve = (id, options) => getNativeRequire().resolve(id, options);
  return {
    __filename: __filename2,
    __dirname,
    require: require3
  };
}
var import_node_module2, import_node_path;
var init_cjs = __esm({
  "node_modules/mlly/lib/cjs.mjs"() {
    init_cjs_shims();
    import_node_module2 = __toModule(require("node:module"));
    import_node_path = __toModule(require("node:path"));
    init_utils2();
  }
});

// node_modules/mlly/lib/resolve.mjs
var import_node_fs2, import_node_url2, DEFAULT_CONDITIONS_SET, DEFAULT_URL, NOT_FOUND_ERRORS;
var init_resolve = __esm({
  "node_modules/mlly/lib/resolve.mjs"() {
    init_cjs_shims();
    import_node_fs2 = __toModule(require("node:fs"));
    import_node_url2 = __toModule(require("node:url"));
    DEFAULT_CONDITIONS_SET = new Set(["node", "import"]);
    DEFAULT_URL = (0, import_node_url2.pathToFileURL)(process.cwd());
    NOT_FOUND_ERRORS = new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND"]);
  }
});

// node_modules/mlly/lib/eval.mjs
var init_eval = __esm({
  "node_modules/mlly/lib/eval.mjs"() {
    init_cjs_shims();
  }
});

// node_modules/mlly/lib/index.mjs
var init_lib = __esm({
  "node_modules/mlly/lib/index.mjs"() {
    init_cjs_shims();
    init_analyze();
    init_cjs();
    init_eval();
    init_resolve();
    init_utils2();
  }
});

// node_modules/local-pkg/index.mjs
function resolveModule(name, options) {
  try {
    return require2.resolve(name, options);
  } catch (e2) {
    return void 0;
  }
}
function isPackageExists(name, options) {
  return !!resolvePackage(name, options);
}
function resolvePackage(name, options = {}) {
  try {
    return require2.resolve(`${name}/package.json`, options);
  } catch {
  }
  try {
    return require2.resolve(name, options);
  } catch (e2) {
    if (e2.code !== "MODULE_NOT_FOUND")
      console.error(e2);
    return false;
  }
}
var import_path3, import_fs2, require2;
var init_local_pkg = __esm({
  "node_modules/local-pkg/index.mjs"() {
    init_cjs_shims();
    import_path3 = __toModule(require("path"));
    import_fs2 = __toModule(require("fs"));
    init_lib();
    ({ require: require2 } = createCommonJS(importMetaUrlShim));
  }
});

// node_modules/@unocss/preset-icons/dist/fs.mjs
var fs_exports2 = {};
__export(fs_exports2, {
  loadCollectionFromFS: () => loadCollectionFromFS
});
async function loadCollectionFromFS(name) {
  if (!_collections[name])
    _collections[name] = task();
  return _collections[name];
  async function task() {
    let jsonPath = resolveModule(`@iconify-json/${name}/icons.json`);
    if (!jsonPath && isLegacyExists)
      jsonPath = resolveModule(`@iconify/json/json/${name}.json`);
    if (jsonPath) {
      const icons = JSON.parse(await import_fs3.promises.readFile(jsonPath, "utf8"));
      return icons;
    } else {
      return void 0;
    }
  }
}
var import_fs3, _collections, isLegacyExists;
var init_fs = __esm({
  "node_modules/@unocss/preset-icons/dist/fs.mjs"() {
    init_cjs_shims();
    import_fs3 = __toModule(require("fs"));
    init_local_pkg();
    _collections = {};
    isLegacyExists = isPackageExists("@iconify/json");
  }
});

// src/index.ts
__export(exports, {
  default: () => src_default2,
  windi: () => windi
});
init_cjs_shims();

// node_modules/@nbhr/utils/dist/index.mjs
init_cjs_shims();

// node_modules/@nbhr/utils/dist/chunk-CZXSWUCG.mjs
init_cjs_shims();

// node_modules/@nbhr/utils/dist/chunk-BZ42Z6RD.mjs
init_cjs_shims();
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};

// node_modules/@nbhr/utils/dist/chunk-CZXSWUCG.mjs
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var fs_exports = {};
__export2(fs_exports, {
  walkSync: () => walkSync
});
function walkSync(path) {
  let files = [];
  const filesInPath = (0, import_fs.readdirSync)(path);
  filesInPath.forEach((file) => {
    const filePath = (0, import_path.normalize)((0, import_path.resolve)((0, import_path.join)(path, file)));
    const stats = (0, import_fs.statSync)(filePath);
    if (stats.isDirectory()) {
      files = files.concat(walkSync(filePath));
    } else if (stats.isFile()) {
      files.push(filePath);
    }
  });
  return files;
}

// node_modules/@nbhr/utils/dist/chunk-SLNUOF4O.mjs
init_cjs_shims();
var debugger_exports = {};
__export2(debugger_exports, {
  createLog: () => createLog
});
function createLog(text, options) {
  console.log(text);
}

// node_modules/@nbhr/utils/dist/index.mjs
var import_url = __toModule(require("url"));
var import_path2 = __toModule(require("path"));
var loader_exports = {};
__export2(loader_exports, {
  load: () => load
});
async function load(file) {
  const path = (0, import_path2.resolve)(file);
  const fileURL = (0, import_url.pathToFileURL)(path);
  let parsed = {};
  if (path.endsWith(".ts")) {
    throw new Error("typescript currently not supported");
  } else {
    const _import = new Function("modulePath", "return import(modulePath)");
    parsed = await _import(fileURL);
    if (parsed.default !== null || parsed.default !== void 0) {
      parsed = parsed.default;
    }
    return parsed;
  }
}

// node_modules/@unocss/core/dist/index.mjs
init_cjs_shims();
function escapeSelector(str) {
  const length = str.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = str.charCodeAt(0);
  while (++index < length) {
    codeUnit = str.charCodeAt(index);
    if (codeUnit === 0) {
      result += "\uFFFD";
      continue;
    }
    if (codeUnit === 44) {
      result += "\\2c ";
      continue;
    }
    if (codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45) {
      result += `\\${codeUnit.toString(16)} `;
      continue;
    }
    if (index === 0 && length === 1 && codeUnit === 45) {
      result += `\\${str.charAt(index)}`;
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += str.charAt(index);
      continue;
    }
    result += `\\${str.charAt(index)}`;
  }
  return result;
}
var e = escapeSelector;
function entriesToCss(arr) {
  if (arr == null)
    return "";
  return arr.map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join("");
}
function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}
function mergeDeep(original, patch) {
  const o = original;
  const p = patch;
  if (Array.isArray(o) && Array.isArray(p))
    return [...o, ...p];
  if (Array.isArray(o))
    return [...o];
  const output = __spreadValues({}, o);
  if (isObject(o) && isObject(p)) {
    Object.keys(p).forEach((key) => {
      if (isObject(p[key])) {
        if (!(key in o))
          Object.assign(output, { [key]: p[key] });
        else
          output[key] = mergeDeep(o[key], p[key]);
      } else {
        Object.assign(output, { [key]: p[key] });
      }
    });
  }
  return output;
}
function isStaticRule(rule) {
  return typeof rule[0] === "string";
}
function isStaticShortcut(sc) {
  return typeof sc[0] === "string";
}
function toArray(value = []) {
  return Array.isArray(value) ? value : [value];
}
function uniq(value) {
  return Array.from(new Set(value));
}
var validateFilterRE = /[a-z?]/;
function isValidSelector(selector = "") {
  return validateFilterRE.test(selector);
}
function normalizeVariant(variant) {
  return typeof variant === "function" ? { match: variant } : variant;
}
function isRawUtil(util) {
  return util.length === 3;
}
var TwoKeyMap = class {
  constructor() {
    this._map = new Map();
  }
  get(key1, key2) {
    const m2 = this._map.get(key1);
    if (m2)
      return m2.get(key2);
  }
  getFallback(key1, key2, fallback) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = new Map();
      this._map.set(key1, m2);
    }
    if (!m2.has(key2))
      m2.set(key2, fallback);
    return m2.get(key2);
  }
  set(key1, key2, value) {
    let m2 = this._map.get(key1);
    if (!m2) {
      m2 = new Map();
      this._map.set(key1, m2);
    }
    m2.set(key2, value);
    return this;
  }
  has(key1, key2) {
    var _a;
    return (_a = this._map.get(key1)) == null ? void 0 : _a.has(key2);
  }
  delete(key1, key2) {
    var _a;
    return ((_a = this._map.get(key1)) == null ? void 0 : _a.delete(key2)) || false;
  }
  deleteTop(key1) {
    return this._map.delete(key1);
  }
  map(fn) {
    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {
      return fn(v, k1, k2);
    }));
  }
};
var extractorSplit = {
  name: "split",
  order: 0,
  extract({ code }) {
    return new Set(code.split(/[\s'"`;>=]+/g).filter(isValidSelector));
  }
};
function resolveShortcuts(shortcuts) {
  return toArray(shortcuts).flatMap((s) => {
    if (Array.isArray(s))
      return [s];
    return Object.entries(s);
  });
}
var defaultLayers = {
  shortcuts: -1,
  default: 0
};
function resolveConfig(userConfig = {}, defaults2 = {}) {
  const config = Object.assign({}, defaults2, userConfig);
  const rawPresets = config.presets || [];
  const sortedPresets = [
    ...rawPresets.filter((p) => p.enforce === "pre"),
    ...rawPresets.filter((p) => !p.enforce),
    ...rawPresets.filter((p) => p.enforce === "post")
  ];
  const layers = Object.assign(defaultLayers, ...rawPresets.map((i) => i.layers), userConfig.layers);
  function mergePresets(key) {
    return uniq([
      ...sortedPresets.flatMap((p) => toArray(p[key] || [])),
      ...toArray(config[key] || [])
    ]);
  }
  const extractors = mergePresets("extractors");
  if (!extractors.length)
    extractors.push(extractorSplit);
  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));
  const rules = mergePresets("rules");
  const rulesStaticMap = {};
  const rulesSize = rules.length;
  rules.forEach((rule, i) => {
    if (isStaticRule(rule)) {
      rulesStaticMap[rule[0]] = [i, rule[1], rule[2]];
      delete rules[i];
    }
  });
  const theme = [
    ...sortedPresets.map((p) => p.theme || {}),
    config.theme || {}
  ].reduce((a, p) => mergeDeep(a, p), {});
  return __spreadProps(__spreadValues({
    mergeSelectors: true,
    warnExcluded: true,
    excluded: [],
    presets: [],
    sortLayers: (layers2) => layers2
  }, config), {
    envMode: config.envMode || "build",
    shortcutsLayer: config.shortcutsLayer || "shortcuts",
    layers,
    theme,
    rulesSize,
    rulesDynamic: rules,
    rulesStaticMap,
    preflights: mergePresets("preflights"),
    variants: mergePresets("variants").map(normalizeVariant),
    shortcuts: resolveShortcuts(mergePresets("shortcuts")),
    extractors
  });
}
var UnoGenerator = class {
  constructor(userConfig = {}, defaults2 = {}) {
    this.userConfig = userConfig;
    this.defaults = defaults2;
    this._cache = new Map();
    this.excluded = new Set();
    this.config = resolveConfig(userConfig, defaults2);
  }
  setConfig(userConfig, defaults2) {
    if (!userConfig)
      return;
    if (defaults2)
      this.defaults = defaults2;
    this.userConfig = userConfig;
    this.config = resolveConfig(userConfig, this.defaults);
    this.excluded = new Set();
    this._cache = new Map();
  }
  async applyExtractors(code, id, set = new Set()) {
    const context = {
      get original() {
        return code;
      },
      code,
      id
    };
    for (const extractor of this.config.extractors) {
      const result = await extractor.extract(context);
      result == null ? void 0 : result.forEach((t) => set.add(t));
    }
    return set;
  }
  async generate(input, {
    id,
    scope,
    preflights = true,
    layerComments = true
  } = {}) {
    const tokens = typeof input === "string" ? await this.applyExtractors(input, id) : input;
    const layerSet = new Set(["default"]);
    const matched = new Set();
    const sheet = new Map();
    const hit = (raw, payload) => {
      var _a;
      this._cache.set(raw, payload);
      matched.add(raw);
      for (const item of payload) {
        const query = item[3] || "";
        if (!sheet.has(query))
          sheet.set(query, []);
        sheet.get(query).push(item);
        if ((_a = item[4]) == null ? void 0 : _a.layer)
          layerSet.add(item[4].layer);
      }
    };
    await Promise.all(Array.from(tokens).map(async (raw) => {
      if (matched.has(raw) || this.excluded.has(raw))
        return;
      if (this._cache.has(raw)) {
        const r = this._cache.get(raw);
        if (r)
          hit(raw, r);
        return;
      }
      if (this.isExcluded(raw)) {
        this.excluded.add(raw);
        this._cache.set(raw, null);
        return;
      }
      const applied = this.matchVariants(raw);
      if (this.isExcluded(applied[1])) {
        this.excluded.add(raw);
        this._cache.set(raw, null);
        return;
      }
      const expanded = this.expandShortcut(applied[1]);
      if (expanded) {
        const utils = await this.stringifyShortcuts(applied, expanded[0], expanded[1]);
        if (utils == null ? void 0 : utils.length) {
          hit(raw, utils);
          return;
        }
      } else {
        const util = this.stringifyUtil(await this.parseUtil(applied));
        if (util) {
          hit(raw, [util]);
          return;
        }
      }
      this._cache.set(raw, null);
    }));
    if (preflights) {
      this.config.preflights.forEach((i) => {
        if (i.layer)
          layerSet.add(i.layer);
      });
    }
    const layerCache = {};
    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => {
      var _a, _b;
      return ((_a = this.config.layers[a]) != null ? _a : 0) - ((_b = this.config.layers[b]) != null ? _b : 0) || a.localeCompare(b);
    }));
    const getLayer = (layer) => {
      if (layerCache[layer])
        return layerCache[layer];
      let css = Array.from(sheet).map(([query, items]) => {
        const size = items.length;
        const sorted = items.filter((i) => {
          var _a;
          return (((_a = i[4]) == null ? void 0 : _a.layer) || "default") === layer;
        }).sort((a, b) => {
          var _a;
          return a[0] - b[0] || ((_a = a[1]) == null ? void 0 : _a.localeCompare(b[1] || "")) || 0;
        }).map((a) => [a[1] ? applyScope(a[1], scope) : a[1], a[2]]);
        if (!sorted.length)
          return void 0;
        const rules = sorted.map(([selector, body], idx) => {
          if (selector && this.config.mergeSelectors) {
            for (let i = size - 1; i > idx; i--) {
              const current = sorted[i];
              if (current && current[0] && current[1] === body) {
                current[0] = `${selector},${current[0]}`;
                return null;
              }
            }
          }
          return selector ? `${selector}{${body}}` : body;
        }).filter(Boolean).join("\n");
        return query ? `${query}{
${rules}
}` : rules;
      }).filter(Boolean).join("\n");
      if (preflights) {
        css = [
          ...this.config.preflights.filter((i) => (i.layer || "default") === layer).map((i) => i.getCSS()).filter(Boolean),
          css
        ].join("\n");
      }
      return layerCache[layer] = layerComments && css ? `/* layer: ${layer} */
${css}` : css;
    };
    const getLayers = (excludes) => {
      return layers.filter((i) => !(excludes == null ? void 0 : excludes.includes(i))).map((i) => getLayer(i) || "").filter(Boolean).join("\n");
    };
    return {
      get css() {
        return getLayers();
      },
      layers,
      getLayers,
      getLayer,
      matched
    };
  }
  matchVariants(raw) {
    const usedVariants = new Set();
    const handlers = [];
    let processed = raw;
    let applied = false;
    while (true) {
      applied = false;
      for (const v of this.config.variants) {
        if (!v.multiPass && usedVariants.has(v))
          continue;
        let handler = v.match(processed, raw, this.config.theme);
        if (!handler)
          continue;
        if (typeof handler === "string")
          handler = { matcher: handler };
        if (handler) {
          processed = handler.matcher;
          handlers.push(handler);
          usedVariants.add(v);
          applied = true;
          break;
        }
      }
      if (!applied)
        break;
      if (handlers.length > 500)
        throw new Error(`Too many variants applied to "${raw}"`);
    }
    return [raw, processed, handlers];
  }
  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {
    const selector = variantHandlers.reduce((p, v) => {
      var _a;
      return ((_a = v.selector) == null ? void 0 : _a.call(v, p)) || p;
    }, toEscapedSelector(raw));
    const mediaQuery = variantHandlers.reduce((p, v) => v.mediaQuery || p, void 0);
    const entries = variantHandlers.reduce((p, v) => {
      var _a;
      return ((_a = v.body) == null ? void 0 : _a.call(v, p)) || p;
    }, parsed[2]);
    return [
      selector,
      entries,
      mediaQuery
    ];
  }
  constructCustomCSS(context, body, overrideSelector) {
    body = normalizeEntries(body);
    const [selector, entries, mediaQuery] = this.applyVariants([0, overrideSelector || context.rawSelector, body, void 0, context.variantHandlers]);
    const cssBody = `${selector}{${entriesToCss(entries)}}`;
    if (mediaQuery)
      return `${mediaQuery}{${cssBody}}`;
    return cssBody;
  }
  async parseUtil(input) {
    const { theme, rulesStaticMap, rulesDynamic, rulesSize } = this.config;
    const [raw, processed, variantHandlers] = typeof input === "string" ? this.matchVariants(input) : input;
    const staticMatch = rulesStaticMap[processed];
    if (staticMatch == null ? void 0 : staticMatch[1])
      return [staticMatch[0], raw, normalizeEntries(staticMatch[1]), staticMatch[2], variantHandlers];
    const context = {
      rawSelector: raw,
      currentSelector: processed,
      theme,
      generator: this,
      variantHandlers,
      constructCSS: (...args) => this.constructCustomCSS(context, ...args)
    };
    for (let i = rulesSize; i >= 0; i--) {
      const rule = rulesDynamic[i];
      if (!rule)
        continue;
      const [matcher, handler, meta] = rule;
      const match = processed.match(matcher);
      if (!match)
        continue;
      const result = await handler(match, context);
      if (!result)
        continue;
      if (typeof result === "string")
        return [i, result, meta];
      const entries = normalizeEntries(result).filter((i2) => i2[1] != null);
      if (entries.length)
        return [i, raw, entries, meta, variantHandlers];
    }
  }
  stringifyUtil(parsed) {
    if (!parsed)
      return;
    if (isRawUtil(parsed))
      return [parsed[0], void 0, parsed[1], void 0, parsed[2]];
    const [selector, entries, mediaQuery] = this.applyVariants(parsed);
    const body = entriesToCss(entries);
    if (!body)
      return;
    return [parsed[0], selector, body, mediaQuery, parsed[3]];
  }
  expandShortcut(processed, depth = 3) {
    if (depth === 0)
      return;
    let meta;
    let result;
    for (const s of this.config.shortcuts) {
      if (isStaticShortcut(s)) {
        if (s[0] === processed) {
          meta = meta || s[2];
          result = s[1];
          break;
        }
      } else {
        const match = processed.match(s[0]);
        if (match)
          result = s[1](match);
        if (result) {
          meta = meta || s[2];
          break;
        }
      }
    }
    if (!result)
      return;
    if (typeof result === "string")
      result = result.split(/ /g);
    return [
      result.flatMap((r) => {
        var _a;
        return ((_a = this.expandShortcut(r, depth - 1)) == null ? void 0 : _a[0]) || [r];
      }),
      meta
    ];
  }
  async stringifyShortcuts(parent, expanded, meta = { layer: this.config.shortcutsLayer }) {
    const selectorMap = new TwoKeyMap();
    const parsed = (await Promise.all(uniq(expanded).map((i) => this.parseUtil(i)))).filter(Boolean).sort((a, b) => a[0] - b[0]);
    const [raw, , parentVariants] = parent;
    for (const item of parsed) {
      if (isRawUtil(item))
        continue;
      const [selector, entries, mediaQuery] = this.applyVariants(item, [...item[4], ...parentVariants], raw);
      const mapItem = selectorMap.getFallback(selector, mediaQuery, [[], item[0]]);
      mapItem[0].push(...entries);
      if (item[0] > mapItem[1])
        mapItem[1] = item[0];
    }
    return selectorMap.map(([entries, index], selector, mediaQuery) => {
      const body = entriesToCss(entries);
      if (body)
        return [index, selector, body, mediaQuery, meta];
      return void 0;
    }).filter(Boolean);
  }
  isExcluded(raw) {
    return this.config.excluded.some((e2) => typeof e2 === "string" ? e2 === raw : e2.test(raw));
  }
};
function createGenerator(config, defaults2) {
  return new UnoGenerator(config, defaults2);
}
var reScopePlaceholder = / \$\$ /;
var hasScopePlaceholder = (css) => css.match(reScopePlaceholder);
function applyScope(css, scope) {
  if (hasScopePlaceholder(css))
    return css.replace(reScopePlaceholder, scope ? ` ${scope} ` : " ");
  else
    return scope ? `${scope} ${css}` : css;
}
function toEscapedSelector(raw) {
  if (raw.startsWith("["))
    return raw.replace(/^\[(.+?)(~?=)"(.*)"\]$/, (_, n, s, i) => `[${e(n)}${s}"${e(i)}"]`);
  else
    return `.${e(raw)}`;
}
function normalizeEntries(obj) {
  return !Array.isArray(obj) ? Object.entries(obj) : obj;
}

// node_modules/@unocss/preset-icons/dist/index.mjs
init_cjs_shims();

// node_modules/@unocss/preset-icons/dist/chunk-USGLYGPO.mjs
init_cjs_shims();
var isNode = typeof process < "u" && typeof process.stdout < "u";
var warned = new Set();
function warnOnce(msg) {
  if (warned.has(msg))
    return;
  console.warn(msg);
  warned.add(msg);
}
function encodeSvg(svg) {
  return svg.replace("<svg", ~svg.indexOf("xmlns") ? "<svg" : '<svg xmlns="http://www.w3.org/2000/svg"').replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/{/g, "%7B").replace(/}/g, "%7D").replace(/</g, "%3C").replace(/>/g, "%3E");
}

// node_modules/@iconify/utils/lib/svg/build.mjs
init_cjs_shims();

// node_modules/@iconify/utils/lib/svg/size.mjs
init_cjs_shims();
var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision === void 0 ? 100 : precision;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

// node_modules/@iconify/utils/lib/svg/build.mjs
function preserveAspectRatio(props) {
  let result = "";
  switch (props.hAlign) {
    case "left":
      result += "xMin";
      break;
    case "right":
      result += "xMax";
      break;
    default:
      result += "xMid";
  }
  switch (props.vAlign) {
    case "top":
      result += "YMin";
      break;
    case "bottom":
      result += "YMax";
      break;
    default:
      result += "YMid";
  }
  result += props.slice ? " slice" : " meet";
  return result;
}
function iconToSVG(icon, customisations) {
  const box = {
    left: icon.left,
    top: icon.top,
    width: icon.width,
    height: icon.height
  };
  let body = icon.body;
  [icon, customisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push("translate(" + (box.width + box.left) + " " + (0 - box.top) + ")");
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push("translate(" + (0 - box.left) + " " + (box.height + box.top) + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue + " " + tempValue + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left) + " " + (box.height / 2 + box.top) + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue + " " + tempValue + ")");
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== 0 || box.top !== 0) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  let width, height;
  if (customisations.width === null && customisations.height === null) {
    height = "1em";
    width = calculateSize(height, box.width / box.height);
  } else if (customisations.width !== null && customisations.height !== null) {
    width = customisations.width;
    height = customisations.height;
  } else if (customisations.height !== null) {
    height = customisations.height;
    width = calculateSize(height, box.width / box.height);
  } else {
    width = customisations.width;
    height = calculateSize(width, box.height / box.width);
  }
  if (width === "auto") {
    width = box.width;
  }
  if (height === "auto") {
    height = box.height;
  }
  width = typeof width === "string" ? width : width + "";
  height = typeof height === "string" ? height : height + "";
  const result = {
    attributes: {
      width,
      height,
      preserveAspectRatio: preserveAspectRatio(customisations),
      viewBox: box.left + " " + box.top + " " + box.width + " " + box.height
    },
    body
  };
  if (customisations.inline) {
    result.inline = true;
  }
  return result;
}

// node_modules/@iconify/utils/lib/customisations/index.mjs
init_cjs_shims();
var defaults = Object.freeze({
  inline: false,
  width: null,
  height: null,
  hAlign: "center",
  vAlign: "middle",
  slice: false,
  hFlip: false,
  vFlip: false,
  rotate: 0
});

// node_modules/@iconify/utils/lib/icon-set/get-icon.mjs
init_cjs_shims();

// node_modules/@iconify/utils/lib/icon/index.mjs
init_cjs_shims();
var iconDefaults = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16,
  rotate: 0,
  vFlip: false,
  hFlip: false
});
function fullIcon(data) {
  return __spreadValues(__spreadValues({}, iconDefaults), data);
}

// node_modules/@iconify/utils/lib/icon/merge.mjs
init_cjs_shims();
function mergeIconData(icon, alias) {
  const result = __spreadValues({}, icon);
  for (const key in iconDefaults) {
    const prop = key;
    if (alias[prop] !== void 0) {
      const value = alias[prop];
      if (result[prop] === void 0) {
        result[prop] = value;
        continue;
      }
      switch (prop) {
        case "rotate":
          result[prop] = (result[prop] + value) % 4;
          break;
        case "hFlip":
        case "vFlip":
          result[prop] = value !== result[prop];
          break;
        default:
          result[prop] = value;
      }
    }
  }
  return result;
}

// node_modules/@iconify/utils/lib/icon-set/get-icon.mjs
function getIconData(data, name, full = false) {
  function getIcon(name2, iteration) {
    var _a, _b, _c, _d;
    if (data.icons[name2] !== void 0) {
      return Object.assign({}, data.icons[name2]);
    }
    if (iteration > 5) {
      return null;
    }
    if (((_a = data.aliases) == null ? void 0 : _a[name2]) !== void 0) {
      const item = (_b = data.aliases) == null ? void 0 : _b[name2];
      const result2 = getIcon(item.parent, iteration + 1);
      if (result2) {
        return mergeIconData(result2, item);
      }
      return result2;
    }
    if (iteration === 0 && ((_c = data.chars) == null ? void 0 : _c[name2]) !== void 0) {
      return getIcon((_d = data.chars) == null ? void 0 : _d[name2], iteration + 1);
    }
    return null;
  }
  const result = getIcon(name, 0);
  if (result) {
    for (const key in iconDefaults) {
      if (result[key] === void 0 && data[key] !== void 0) {
        result[key] = data[key];
      }
    }
  }
  return result && full ? fullIcon(result) : result;
}

// node_modules/@unocss/preset-icons/dist/index.mjs
var COLLECTION_NAME_PARTS_MAX = 3;
async function searchForIcon(collection, id, collections, scale) {
  let iconSet = collections[collection];
  if (typeof iconSet === "function")
    iconSet = await iconSet();
  if (!iconSet && isNode) {
    const { loadCollectionFromFS: loadCollectionFromFS2 } = await Promise.resolve().then(() => (init_fs(), fs_exports2));
    iconSet = await loadCollectionFromFS2(collection);
  }
  if (!iconSet)
    return;
  const iconData = getIconData(iconSet, id, true);
  if (iconData) {
    const { attributes, body } = iconToSVG(iconData, __spreadProps(__spreadValues({}, defaults), {
      height: `${scale}em`,
      width: `${scale}em`
    }));
    return `<svg ${Object.entries(attributes).map((i) => `${i[0]}="${i[1]}"`).join(" ")}>${body}</svg>`;
  }
}
var preset = ({
  scale = 1,
  mode = "auto",
  prefix = "i-",
  warn = false,
  collections = {},
  extraProperties = {},
  layer = "icons"
} = {}) => {
  return {
    name: "@unocss/preset-icons",
    enforce: "pre",
    layers: {
      icons: -10
    },
    rules: [[
      new RegExp(`^${prefix}([a-z0-9:-]+)$`),
      async ([full, body]) => {
        let collection = "";
        let name = "";
        let svg;
        if (body.includes(":")) {
          [collection, name] = body.split(":");
          svg = await searchForIcon(collection, name, collections, scale);
        } else {
          const parts = body.split(/-/g);
          for (let i = COLLECTION_NAME_PARTS_MAX; i >= 1; i--) {
            collection = parts.slice(0, i).join("-");
            name = parts.slice(i).join("-");
            svg = await searchForIcon(collection, name, collections, scale);
            if (svg)
              break;
          }
        }
        if (!svg) {
          if (warn)
            warnOnce(`[unocss] failed to load icon "${full}"`);
          return;
        }
        let _mode = mode;
        if (_mode === "auto")
          _mode = svg.includes("currentColor") ? "mask" : "background-img";
        const url = `url("data:image/svg+xml;utf8,${encodeSvg(svg)}")`;
        if (_mode === "mask") {
          return __spreadValues({
            "--un-icon": url,
            "mask": "var(--un-icon) no-repeat",
            "mask-size": "100% 100%",
            "-webkit-mask": "var(--un-icon) no-repeat",
            "-webkit-mask-size": "100% 100%",
            "background-color": "currentColor",
            "height": `${scale}em`,
            "width": `${scale}em`
          }, extraProperties);
        } else {
          return __spreadValues({
            "background": `${url} no-repeat`,
            "background-size": "100% 100%",
            "background-color": "transparent",
            "height": `${scale}em`,
            "width": `${scale}em`
          }, extraProperties);
        }
      },
      { layer }
    ]]
  };
};
var src_default = preset;

// src/index.ts
var import_fs4 = __toModule(require("fs"));
var import_lib = __toModule(require("windicss/lib"));
var import_parser = __toModule(require("windicss/utils/parser"));

// src/utils.ts
init_cjs_shims();
var import_style = __toModule(require("windicss/utils/style"));
function combineStyleList(stylesheets) {
  return stylesheets.reduce((previousValue, currentValue) => previousValue.extend(currentValue), new import_style.StyleSheet()).combine();
}
function globalStyleSheet(styleSheet) {
  styleSheet.children.forEach((style) => {
    if (!style.rule.includes(":global") && style.meta.group !== "keyframes") {
      style.wrapRule((rule) => `:global(${rule})`);
    }
    if (style.atRules && !style.atRules.includes("-global-") && style.meta.group == "keyframes") {
      style.atRules[0] = style.atRules[0].replace(/(?<=keyframes )(?=\w)/gi, "-global-");
    }
  });
  return styleSheet;
}
var Magician = class {
  constructor(processor, content, filename, config = {}, userConfig = {}, uno) {
    this.isBundled = false;
    this.isCompiled = false;
    this.lines = [];
    this.expressions = [];
    this.directives = [];
    this.attributifies = new Map();
    this.classes = [];
    this.stylesheets = [];
    this.config = {};
    this.userConfig = {};
    this.stats = new Map();
    this.computed = void 0;
    this.computedStyleSheet = new import_style.StyleSheet();
    this.css = "";
    this.processor = processor;
    this.content = content;
    this.filename = filename;
    this.config = config;
    this.userConfig = userConfig;
    if (uno) {
      this.uno = uno;
    }
  }
  getStats() {
    return this.stats;
  }
  prepare() {
    let tmpContent = this.content;
    tmpContent = tmpContent.replace(/<!--[\s\S]*?-->/g, "");
    tmpContent = tmpContent.replace(/([!\w][\w:_/-]*?):\(([\w\s/-]*?)\)/gm, (_, groupOne, groupTwo) => groupTwo.split(/\s/g).map((cssClass) => `${groupOne}:${cssClass}`).join(" "));
    this.content = tmpContent;
    return this;
  }
  setInject() {
    let tmpContent = this.content;
    tmpContent = tmpContent.replace("windi:inject", "");
    const styleMatch = tmpContent.match(/(?<openTag><style[^>]*?>)(?<content>[\s\S]*?)(?<closeTag><\/style>)/gi);
    if (styleMatch) {
      tmpContent = tmpContent.replace("<style", "<style windi:inject");
    } else {
      tmpContent += "\n<style windi:inject>\n</style>";
    }
    this.content = tmpContent;
    return this;
  }
  processClassAttribute() {
    const tmpContent = this.content;
    const CLASS_MATCHES = [...tmpContent.matchAll(/(class)=(['"])(?<classes>[^\2]*?)\2/gi)];
    if (CLASS_MATCHES.length < 1)
      return this;
    for (const match of CLASS_MATCHES) {
      const cleanedMatch = match[3].replace(/windi[`].+?[`]|(?<![-])[$](?=[{])|(?<=([{][\w\s]+[^{]*?))['"]|(?<=([{][\w\s]+[^{]*?))\s[:]|([{][\w\s]+[^{]*?[?])|^[{]|(?<=["'`)])[}]/gi, " ").replace(/\n/gi, " ").replace(/ {2,}/gi, " ").replace(/["'`]/gi, "");
      this.classes = this.classes.concat(cleanedMatch.split(" ").filter((c) => {
        return c.length > 0;
      }));
    }
    this.content = tmpContent;
    return this;
  }
  processDirectiveClass() {
    const tmpContent = this.content;
    const DIRECTIVE_CLASS_MATCHES = [...tmpContent.matchAll(/\s(class):(?<class>[^=]+)(=)/gi)];
    if (DIRECTIVE_CLASS_MATCHES.length < 1)
      return this;
    for (const match of DIRECTIVE_CLASS_MATCHES) {
      this.directives = this.directives.concat(match[2]);
    }
    this.content = tmpContent;
    return this;
  }
  processWindiExpression() {
    const tmpContent = this.content;
    const WINDI_MATCHES = [...tmpContent.matchAll(/windi`(?<class>.*?)`/gi)];
    if (WINDI_MATCHES.length < 1)
      return this;
    for (const match of WINDI_MATCHES) {
      const cleanedMatch = match[1].replace(/(?<![-])[$](?=[{])|(?<=([{][\w\s]+[^{]*?))['":]|([{][\w\s]+[^{]*?[?])|^[{]|(?<=["'`)])[}]/gi, " ").replace(/ {2,}/gi, " ").replace(/["'`]/gi, "");
      this.expressions = this.expressions.concat(cleanedMatch.split(" "));
    }
    this.content = tmpContent;
    return this;
  }
  processAttributify() {
    const tmpContent = this.content;
    const ATTRIBUTIFY_CLASS_MATCHES = [...tmpContent.matchAll(/([\w+:_/-]+)=(['"])(?<classes>[^\2]*?)\2/gi)];
    if (ATTRIBUTIFY_CLASS_MATCHES.length < 1)
      return this;
    for (const match of ATTRIBUTIFY_CLASS_MATCHES) {
      if (match[1] == "class")
        continue;
      if (match[1] == "href")
        continue;
      if (match[1] == "this")
        continue;
      if (match[1] == "name")
        continue;
      if (match[1] == "stroke")
        continue;
      if (match[1] == "d")
        continue;
      if (match[1] == "slot")
        continue;
      if (match[1] == "viewBox")
        continue;
      if (match[1] == "points")
        continue;
      if (match[1] == "label")
        continue;
      if (match[1] == "xmlns")
        continue;
      if (match[1].startsWith("class:"))
        continue;
      const cleanedMatch = match[3].replace(/windi[`].+?[`]|(?<![-])[$](?=[{])|(?<=([{][\w\s]+[^{]*?))['"]|(?<=([{][\w\s]+[^{]*?))\s[:]|([{][\w\s]+[^{]*?[?])|^[{]|(?<=["'`)])[}]/gi, " ").replace(/ {2,}/gi, " ").replace(/["'`]/gi, "");
      if (this.attributifies.has(match[1].toString())) {
        const oldValue = this.attributifies.get(match[1].toString());
        if (oldValue) {
          this.attributifies.set(match[1].toString(), oldValue.concat(cleanedMatch.split(" ")));
        }
      } else {
        this.attributifies.set(match[1].toString(), cleanedMatch.split(" "));
      }
    }
    this.content = tmpContent;
    return this;
  }
  compute() {
    var _a;
    const tmpContent = this.content;
    const defaultSet = new Set(this.classes.concat(this.directives).concat(this.expressions));
    if (((_a = this.userConfig.experimental) == null ? void 0 : _a.icons) != void 0 && this.uno) {
      const iconSet = new Set([...defaultSet.values()].filter((c) => c.startsWith("i-")));
      this.unoCSS = this.uno.generate(iconSet);
    }
    const INTERPRETED_DEFAULT = this.processor.interpret(Array.from(defaultSet).join(" "));
    this.attributifies.forEach((v, k) => {
      const unique = new Set(v);
      this.attributifies.set(k, Array.from(unique));
    });
    const INTERPRETED_ATTRIBUTIFY = this.processor.attributify(Object.fromEntries(this.attributifies));
    this.stylesheets.push(INTERPRETED_DEFAULT.styleSheet);
    this.stylesheets.push(INTERPRETED_ATTRIBUTIFY.styleSheet);
    this.computed = { default: INTERPRETED_DEFAULT, attributify: INTERPRETED_ATTRIBUTIFY };
    this.computedStyleSheet = combineStyleList(this.stylesheets).sort();
    this.content = tmpContent;
    return this;
  }
  getCode() {
    return this.content;
  }
  getComputed() {
    return this.computed;
  }
  getComputedStyleSheet() {
    return this.computedStyleSheet;
  }
  getUnoCSS() {
    return this.unoCSS;
  }
  getExtracted() {
    return this.css;
  }
  getFilename() {
    return this.filename;
  }
};

// src/index.ts
var OPTIONS = {
  silent: false,
  disableFormat: false,
  devTools: {
    enabled: false
  },
  safeList: void 0,
  preflights: true
};
var DEV = false;
var PROCESSOR;
var UNO;
var windiConfig;
var configMTime;
var CSS_SOURCE = "";
var CSS_STYLESHEETS = new Map();
var UNO_CSS = new Map();
function _preprocess(content, filename) {
  let mag = new Magician(PROCESSOR, content, filename, windiConfig, OPTIONS, UNO);
  mag = mag.prepare();
  mag = mag.setInject();
  mag = mag.processClassAttribute().processDirectiveClass().processWindiExpression();
  mag = mag.processAttributify();
  mag = mag.compute();
  CSS_STYLESHEETS.set(filename, { code: mag.getComputedStyleSheet(), lastmodified: new Date() });
  UNO_CSS.set(filename, mag.getUnoCSS() || Promise.resolve({ css: "", matched: "" }));
  return mag.getCode();
}
function loadConfig(path) {
  debugger_exports.createLog("Trying to load windi configuration from " + path);
  return loader_exports.load(path).then((config) => {
    configMTime = Date.now();
    if (config.preflight === false)
      OPTIONS.preflights = false;
    if (config.safelist && typeof config.safelist == "string") {
      OPTIONS.safeList = config.safelist;
    } else if (config.safelist) {
      const tmpSafelist = config.safelist;
      OPTIONS.safeList = [...new Set(tmpSafelist.flat(Infinity))].join(" ");
    }
    console.log(config);
    console.log(JSON.stringify(config.theme));
    PROCESSOR.loadConfig(config);
    debugger_exports.createLog("Configuration loaded successfully");
    windiConfig = config;
  });
}
function windi(options = {}) {
  PROCESSOR = new import_lib.Processor();
  OPTIONS = __spreadValues(__spreadValues({}, OPTIONS), options);
  if (OPTIONS.experimental && OPTIONS.experimental.icons != void 0) {
    UNO = createGenerator({
      presets: [
        src_default(__spreadValues({}, OPTIONS.experimental.icons))
      ]
    }, {});
  }
  DEV = false;
  if (process.env.NODE_ENV === "production")
    DEV = false;
  if (process.env.NODE_ENV === "development")
    DEV = true;
  if (OPTIONS.mode === "production")
    DEV = false;
  if (OPTIONS.mode === "development")
    DEV = true;
  return {
    markup: ({ content, filename }) => {
      return new Promise((resolve3) => {
        if (windiConfig != void 0) {
          if (OPTIONS.configPath) {
            const mTime = (0, import_fs4.statSync)(OPTIONS.configPath).mtimeMs;
            if (mTime > configMTime) {
              const tmpConfigPath = `./${Date.now()}windi.config.js`;
              (0, import_fs4.copyFileSync)(OPTIONS.configPath, tmpConfigPath);
              loadConfig(tmpConfigPath).catch((e2) => {
                debugger_exports.createLog("Unknown Error while loading the config");
                console.error(e2);
              }).finally(() => {
                (0, import_fs4.rmSync)(tmpConfigPath);
                resolve3({
                  code: _preprocess(content, filename)
                });
              });
            } else {
              resolve3({
                code: _preprocess(content, filename)
              });
            }
          }
        } else {
          if (OPTIONS.configPath) {
            loadConfig(OPTIONS.configPath).catch((e2) => {
              debugger_exports.createLog("Unknown Error while loading the config");
              console.error(e2);
            }).finally(() => {
              resolve3({
                code: _preprocess(content, filename)
              });
            });
          } else {
            PROCESSOR.loadConfig();
            resolve3({
              code: _preprocess(content, filename)
            });
          }
        }
      });
    },
    script: ({ content, attributes }) => {
      return new Promise((resolve3) => {
        if (DEV === true && OPTIONS.devTools && OPTIONS.devTools.enabled !== false && attributes["windi:devtools"]) {
          console.log("DevTools are currently in an rework. ");
          resolve3({
            code: content
          });
        } else {
          resolve3({
            code: content
          });
        }
      });
    },
    style: ({ content, attributes, filename }) => {
      return new Promise(async (resolve3) => {
        let PREFLIGHTS_STYLE = "";
        let SAFELIST_STYLE = "";
        let CSS_STYLE = "";
        let INLINE_STYLE = "";
        let UNO_STYLE = "";
        if (OPTIONS.preflights === true && attributes["windi:preflights:global"]) {
          const PREFLIGHTS = PROCESSOR.preflight();
          PREFLIGHTS_STYLE = globalStyleSheet(PREFLIGHTS).build();
        } else if (OPTIONS.preflights === true && attributes["windi:preflights"]) {
          const PREFLIGHTS = PROCESSOR.preflight();
          PREFLIGHTS_STYLE = PREFLIGHTS.build();
        }
        if (OPTIONS.safeList && attributes["windi:safelist:global"]) {
          const SAFELIST = PROCESSOR.interpret(OPTIONS.safeList).styleSheet;
          SAFELIST_STYLE = globalStyleSheet(SAFELIST).build();
          if (OPTIONS.experimental && OPTIONS.experimental.icons != void 0) {
            let UNO_SAFELIST_STYLE = "";
            const { css } = await UNO.generate(OPTIONS.safeList);
            const UNO_SAFELIST_STYLESHEET = new import_parser.CSSParser(css).parse();
            UNO_SAFELIST_STYLE = globalStyleSheet(UNO_SAFELIST_STYLESHEET).build();
            SAFELIST_STYLE += UNO_SAFELIST_STYLE;
          }
        } else if (OPTIONS.safeList && attributes["windi:safelist"]) {
          const SAFELIST = PROCESSOR.interpret(OPTIONS.safeList).styleSheet;
          SAFELIST_STYLE = SAFELIST.build();
          if (OPTIONS.experimental && OPTIONS.experimental.icons != void 0) {
            let UNO_SAFELIST_STYLE = "";
            const { css } = await UNO.generate(OPTIONS.safeList);
            UNO_SAFELIST_STYLE = css;
            SAFELIST_STYLE += UNO_SAFELIST_STYLE;
          }
        }
        let CSS;
        CSS_SOURCE = content;
        if (CSS_SOURCE && attributes["global"]) {
          CSS = new import_parser.CSSParser(CSS_SOURCE, PROCESSOR).parse();
          CSS_STYLE = globalStyleSheet(CSS).build();
        } else if (CSS_SOURCE) {
          const tmpCSS = CSS_SOURCE;
          const rules = [...tmpCSS.matchAll(/(?<selector>[^}]*){(?<css>[^}]*)}/gim) || []];
          rules.forEach((rule) => {
            if (rule.groups && rule.groups.selector.includes(":global")) {
              const globalCSS = new import_parser.CSSParser(rule[0], PROCESSOR).parse();
              const buildGlobalCSS = globalStyleSheet(globalCSS).build();
              if (buildGlobalCSS.length > 0)
                CSS_STYLE += buildGlobalCSS + "\n";
            } else {
              CSS = new import_parser.CSSParser(rule[0], PROCESSOR).parse();
              const buildLocalCSS = CSS.build();
              if (buildLocalCSS.length > 0)
                CSS_STYLE += buildLocalCSS + "\n";
            }
          });
        }
        const FILESHEET = CSS_STYLESHEETS.get(filename || "") || void 0;
        if (FILESHEET && attributes["windi:global"]) {
          INLINE_STYLE = globalStyleSheet(FILESHEET["code"]).build();
        } else if (FILESHEET) {
          INLINE_STYLE = FILESHEET["code"].build();
        }
        if (filename && UNO_CSS.has(filename)) {
          const { css } = await UNO_CSS.get(filename);
          UNO_STYLE += css;
        }
        let newStyleCode = "\n";
        if (PREFLIGHTS_STYLE.length > 0)
          newStyleCode += PREFLIGHTS_STYLE + "\n";
        if (SAFELIST_STYLE.length > 0)
          newStyleCode += SAFELIST_STYLE + "\n";
        if (CSS_STYLE.length > 0)
          newStyleCode += CSS_STYLE + "\n";
        if (INLINE_STYLE.length > 0)
          newStyleCode += INLINE_STYLE + "\n";
        if (UNO_STYLE.length > 0)
          newStyleCode += UNO_STYLE + "\n";
        resolve3({
          code: newStyleCode
        });
      });
    }
  };
}
var src_default2 = windi;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  windi
});
